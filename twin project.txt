Ignorer et passer au contenu
Historique de chat

Vous avez dit :
Digital twin crossfit, avoir une 10 de paramètres pour un athlète et pouvoir lancer des clones de lui avec des shift en paramètre sur certains wod pour trouver la stratégie la plus optimal, comment faire ?

Paramètres contexte (temps, altitude etc..) paramètres athlète (max back squat, ftp..) et paramètre ressenti(rpe, sommeil, ) 
ChatGPT a dit :
Pour bien t’aider à concevoir un jumeau numérique pour un athlète CrossFit, pourrais-tu préciser :

Quels types de WODs veux-tu modéliser ? (ex : AMRAP, For Time, EMOM, Hero WODs...)

Souhaites-tu intégrer une modélisation physiologique, biomécanique ou rester sur une simulation basée sur des données statistiques ?

Comptes-tu utiliser une plateforme particulière (Python, Unity, AnyLogic, autres) ou veux-tu des recommandations ?

Veux-tu des suggestions d’outils / frameworks existants pour créer des clones et tester des variations de paramètres ?

Avec ces précisions, je pourrai lancer une recherche ciblée sur les solutions existantes ou une approche de modélisation adaptée à ton besoin.

Vous avez dit :
Tous les wods, des stats pour commencer,python,pq pas 
ChatGPT a dit :
Parfait. Je vais rechercher comment créer un jumeau numérique d’un athlète CrossFit en Python, basé sur une approche statistique, permettant de simuler tous types de WODs avec environ 10 paramètres divisés en trois catégories :

Contexte (ex. : altitude, température, etc.)

Athlète (ex. : max back squat, FTP, VMA, etc.)

Ressenti (ex. : sommeil, fatigue, RPE, etc.)

L’objectif est de pouvoir cloner cet athlète en faisant varier certains paramètres et lancer des simulations sur différents WODs afin d’identifier la stratégie optimale.

Je reviens vers toi avec un plan de modélisation, les outils à utiliser, et éventuellement des exemples de code ou de framework utiles.

Research completed in 10m· 16 sources· 91 recherches
Jumeau numérique CrossFit pour simulation de stratégies WOD en Python

Conception d'un jumeau numérique pour un athlète de CrossFit
La création d’un jumeau numérique d’un athlète de CrossFit consiste à modéliser, sous forme logicielle, ses performances potentielles sur divers entraînements ("WODs") en fonction de plusieurs paramètres. Plutôt que de simuler la biomécanique précise des mouvements, l’approche retenue ici est statistique et orientée données : on utilise des relations empiriques et des modèles mathématiques pour prédire les résultats (temps, nombre de répétitions, puissance, etc.) d’un athlète donné sur un WOD, en tenant compte de facteurs multiples. Le but est de pouvoir "cloner" virtuellement l'athlète – c’est-à-dire créer des copies simulées de lui avec de légères variations dans certains paramètres (ex : +5% de force, niveau de fatigue différent, conditions environnementales modifiées) – afin de tester différentes configurations ou stratégies sur des WODs variés. En comparant les performances simulées de ces clones, on pourra dégager la stratégie optimale pour l’athlète réel (choix du rythme, découpage des séries, gestion des pauses, etc.).
Approche de modélisation statistique
La performance en CrossFit est multifactorielle, il faut donc un modèle intégrant divers types de variables. Un examen systématique de la littérature a conclu qu’aucun paramètre unique ne permet de prédire la performance sur l’ensemble des WODs ; en revanche, des facteurs physiologiques comme la composition corporelle (par ex. faible masse grasse) et l’expérience compétitive ont une influence significative et récurrente
pubmed.ncbi.nlm.nih.gov
. En pratique, la force maximale de l’athlète (par ex. le poids soulevé au back squat ou le "CrossFit Total" qui est la somme de 3 max lifts) se montre fortement corrélée aux performances sur des WODs courts et lourds
mdpi.com
, alors que l’endurance aérobie (VMA, VO₂max, etc.) joue un rôle majeur dans les efforts prolongés de type AMRAP
mdpi.com
. D’autres capacités comme la tolérance à la fatigue et la récupération entre efforts intenses (mesurée par exemple via la capacité à répéter des efforts de Wingate) se révèlent également prédictives du succès sur des entraînements à haute intensité répétée
mdpi.com
. Il est donc recommandé de bâtir un modèle qui combine environ 10 paramètres couvrant ces différentes dimensions : des paramètres athlète (force, puissance, endurance, poids de corps, etc.), des paramètres de contexte (environnement : température, altitude, humidité, etc.) et des paramètres de ressenti subjectif (fatigue aiguë, qualité du sommeil, stress, RPE du jour, etc.). Les paramètres de contexte modulent directement les capacités de l’athlète et doivent être inclus dans le modèle. Par exemple, une haute altitude réduit la puissance aérobie disponible (diminution de la VO₂ max), ce qui fait qu'un effort qui serait aisé au niveau de la mer devient beaucoup plus difficile en montagne
skratchlabs.com
. De même, une forte chaleur combinée à une humidité élevée accélère la dérive cardiovasculaire et la surchauffe du corps : au-delà d’un indice de chaleur critique (~30 °C ressenti), chaque exercice demande un effort perçu plus important à cause d’une évaporation de la sueur moins efficace
trainingpeaks.com
. Dans le modèle statistique, on peut représenter ces effets par des coefficients d’ajustement appliqués aux performances de base de l’athlète (par ex., multiplier les temps de parcours ou de repos par un facteur >1 si 35 °C et 80% d’humidité, ou diminuer proportionnellement la VMA en altitude). Pour mettre en œuvre la modélisation statistique, plusieurs approches sont possibles :
Modèle supervisé (apprentissage automatique) : Si l’on dispose de données historiques liant des caractéristiques d’athlète à des résultats sur des WODs, on peut entraîner un modèle prédictif. Par exemple, une régression linéaire multiple ou un algorithme de Random Forest permettront d’estimer le temps de complétion d’un WOD donné à partir des 10 paramètres en entrée. Une étude récente a utilisé un Random Forest (et une régression multiple en comparaison) pour prédire les performances de CrossFit sur des exercices de force (snatch, clean & jerk, back squat, deadlift), obtenant une excellente précision (R² jusqu’à 0,80–0,93 selon l’exercice)
preprints.org
. Ce type de modèle d’ensemble est adapté pour capturer des interactions non linéaires entre variables. On pourrait de même envisager un modèle de gradient boosting (XGBoost/LightGBM) ou un réseau de neurones peu profond pour affiner la prédiction. L’avantage d’un modèle purement data-driven est qu’il peut apprendre les relations complexes directement depuis les données, par exemple l'impact combiné d'une haute température et d'un état de fatigue sur le temps au WOD.
Simulation algorithmique de la performance : En l’absence de grand jeu de données, on peut opter pour une simulation basée sur des règles physiologiques simplifiées. Il s’agit de modéliser le déroulement d’un WOD pas à pas en calculant le temps écoulé et la fatigue accumulée. Par exemple, on peut estimer que sans fatigue, l'athlète réalise une répétition d’un certain mouvement en t0 secondes (valeur déterminée par sa puissance ou sa vitesse propre) ; puis intégrer un modèle de fatigue qui augmente progressivement ce temps de réalisation au fil des répétitions ou des tours. On peut s’inspirer de modèles éprouvés comme la notion de puissance critique : tant que l’athlète reste sous un certain seuil d’intensité, il peut soutenir l’effort longtemps, mais au-dessus de ce seuil il puise dans une réserve d’énergie limitée (W’), qui une fois épuisée impose de ralentir ou de faire une pause. Concrètement, la simulation calcule pour chaque segment du WOD (course, séries de mouvements…) la dépense énergétique et son effet sur l'état de fatigue de l’athlète, et décide de pauses lorsque nécessaire. Ce type de simulation peut être raffiné en ajoutant une part de variabilité stochastique (par ex., en tirant aléatoirement le temps de réalisation exact de chaque rep autour d’une moyenne) – on parle alors de Monte Carlo pour explorer plusieurs déroulements possibles. L’avantage de l’approche simulation est qu’elle permet de tester des scénarios de stratégie (voir point suivant) et d’estimer l’influence de chaque paramètre en manipulant ceux-ci dans le code.
Prise en compte de la stratégie de pacing : Afin de déterminer la meilleure stratégie, le modèle doit permettre d’ajuster des paramètres de stratégie. Par exemple, on peut introduire un paramètre représentant le rythme initial (à quelle intensité relative l’athlète démarre-t-il le WOD ? 90% de sa vitesse maximale vs 70% pour économiser ses forces) ou la taille des séries (combien de répétitions fait-il d’affilée avant de prendre une pause sur un mouvement donné). Dans une simulation, ces paramètres influenceront quand et combien de repos l’algorithme insère. On peut également modéliser le choix de l’ordre des exercices s’il n’est pas imposé (par exemple, dans un WOD où l’on pourrait interchanger des segments, comme courir avant ou après des levés). En dupliquant le clone de base en plusieurs clones virtuels chacun doté d’une stratégie différente, on peut simuler plusieurs approches pour un même WOD et comparer les résultats. Cette exploration systématique aide à identifier la stratégie optimale (par ex. mieux vaut fractionner les séries de 21 reps en 3×7 reps avec 10 secondes de pause, plutôt que tenter 21 reps unbroken et exploser ensuite).
Outils et bibliothèques Python utiles
Plusieurs outils Python peuvent faciliter la création de ce jumeau numérique. Pour la partie modélisation statistique, on exploitera des bibliothèques comme pandas (stockage et manipulation des données d’entrées/sorties), NumPy (calculs numériques efficaces, simulation aléatoire), et surtout scikit-learn (pour entraîner un modèle de régression, de forêt aléatoire, etc., et évaluer sa performance). Des frameworks de gradient boosting comme XGBoost ou LightGBM sont également utiles pour tester des modèles prédictifs performants sur de petits jeux de données. Si l’on s’oriente vers une simulation manuelle, la librairie SimPy peut être utilisée pour gérer la chronologie des événements (exécutions d’exercices, temps de repos) dans une perspective de simulation d’événements discrets. En pratique, il est aussi possible de coder la simulation plus simplement via des boucles Python ou des opérations vectorisées NumPy si le modèle mathématique est défini. Pour explorer des stratégies de manière automatisée, on pourrait même encadrer le problème comme un environnement Gym (OpenAI) personnalisé : cela permettrait d’utiliser des techniques d’apprentissage par renforcement (via stable-baselines par ex.) où un agent essaie différentes séquences d’actions (rythmes, pauses) pour maximiser le score du WOD. Cependant, cette approche est plus complexe à mettre en place et nécessite de définir clairement l’état du système (par ex. état de fatigue actuel, exercices restants…) et les actions possibles à chaque étape du WOD. Enfin, pour la partie analyse et visualisation (voir plus bas), des bibliothèques de visualisation comme Matplotlib/Seaborn ou Plotly seront utiles afin de créer des graphiques comparant les performances des clones.
Jeux de données pour entraînement et test
Trouver ou constituer un jeu de données adéquat est crucial pour entraîner et valider le modèle de performance. Quelques pistes de données :
Données de compétitions CrossFit : Il existe des datasets publics compilant les performances à des compétitions. Par exemple, un dataset Kaggle intitulé CrossFit Athletes rassemble des informations démographiques sur des athlètes (âge, sexe, expérience) ainsi que leurs métriques de performance (temps, poids soulevés, répétitions) sur divers événements CrossFit
lightningchart.com
. Ce jeu de données couvre différentes compétitions (Open, Regionals, etc.) et offre un point de départ pour analyser quelles variables sont le plus corrélées aux résultats. On y observe une grande variabilité inter-individuelle et des tendances (par ex. les athlètes mieux classés ont souvent des charges maximales plus élevées et un pourcentage de masse grasse plus bas
pubmed.ncbi.nlm.nih.gov
). Ces données peuvent servir à entraîner un modèle prédictif général ou à vérifier que la simulation statistique produit des résultats réalistes en les comparant aux performances réelles.
Données d’entraînement de l’athlète cible : Pour personnaliser le jumeau numérique, l’idéal est de collecter des données in situ sur l’athlète en question. Par exemple, enregistrer ses temps ou scores sur plusieurs WODs types, tout en notant les paramètres contextuels et subjectifs du jour (ex : WOD “Fran” réalisé en 4′30″ dans une box à 25 °C, athlète bien reposé avec RPE 9/10). Même avec une dizaine de points de données bien choisis, on peut calibrer certains paramètres du modèle (par ex. le coefficient de fatigue, la relation entre RPE et baisse de performance). En l’absence de données suffisantes, on peut aussi générer des données artificielles en utilisant le modèle simulé lui-même : on attribue des valeurs aléatoires crédibles aux 10 paramètres (en se basant sur la plage de variation possible connue), puis on simule le WOD pour obtenir un “pseudo-résultat”. En répétant ce processus des centaines ou milliers de fois (Monte Carlo), on crée un jeu de données synthétique qui pourra entraîner un modèle de machine learning et aider à tester la robustesse du jumeau numérique.
Données issues de la littérature scientifique : Certaines études publiées sur les performances en CrossFit donnent des indications chiffrées qui peuvent affiner le modèle. Par exemple, une étude de 2020 sur les participants du CrossFit Open 2018 a trouvé que le pourcentage de gras, la surface musculaire de la cuisse et le seuil ventilatoire expliquaient 55–80% de la variance de performance selon les WOD
mdpi.com
. Une autre a montré que la capacité à maintenir la puissance sur 4 sprints Wingate consécutifs était un bon prédicteur de la performance sur un WOD AMRAP de 15 min
mdpi.com
. Intégrer ces tendances permet de régler les pondérations du modèle (par ex., vérifier que diminuer le paramètre "sommeil" ou augmenter "stress" dans la simulation impacte négativement la performance, cohérent avec l’idée d’une fatigue chronique).
En combinant ces sources, on aura un dataset pour entraîner le modèle (si approche ML) et pour valider la fidélité du jumeau numérique (en comparant ses prédictions aux cas réels documentés).
Plan d’implémentation en Python
Pour structurer le code Python de ce projet, on peut suivre une démarche en plusieurs étapes :
Définition des classes de base : Créez une classe Athlete pour représenter l’athlète avec ses attributs (force, FTP, VMA, poids, etc.), et une classe WOD pour représenter un workout. La classe WOD contiendra le type de WOD (AMRAP, For Time, EMOM, etc.), la liste des exercices composant le WOD avec leurs paramètres (par ex. 21-15-9 thrusters 42,5 kg & pull-ups pour “Fran”, ou AMRAP 15 min de 5 burpees, 10 squats, 15 sit-ups), et éventuellement la durée limite s’il y en a une. On peut également définir une structure pour l’environnement (contexte) contenant température, humidité, altitude, afin que ces infos soient facilement transmissibles au modèle de performance.
Implémentation du modèle de performance : Cette étape dépend de l’approche choisie. Si on a entraîné un modèle de machine learning (par ex. un Random Forest), on définira une fonction predire_performance(athlete, wod, env) qui extrait les features appropriées de l’athlète (athlete.max_back_squat, athlete.VMA, etc., combinés avec les données du env comme la température) et retourne une prédiction du temps ou du score. Si on part sur une simulation manuelle, on écrit une fonction simuler_wod(athlete, wod, env, strategie) qui va itérer sur le déroulement du WOD. Par exemple, pour un WOD For Time en plusieurs rounds, on boucle sur les tours et les exercices : on calcule le temps pour accomplir chaque série de répétitions en fonction des capacités de l’athlète. On peut modéliser le temps par répétition comme une variable dépendant de la force de l’athlète (plus il est fort par rapport à la charge, plus l’exécution est rapide) et de la fatigue accumulée. On inclut la logique de pause : si l’athlète simulé doit réaliser 15 thrusters à 50 kg mais qu’après 10 thrusters la fatigue atteint un seuil critique, la fonction ajoute une pause (dont la durée peut dépendre du niveau de fatigue ou être paramétrée via la stratégie). Au final, la fonction retourne le temps total réalisé (ou le nombre de reps effectuées si AMRAP).
Calibration et validation : Avant de lancer des simulations de masse, il est important de valider que le modèle reproduit raisonnablement la réalité. Pour cela, on peut comparer la sortie de predire_performance ou simuler_wod à des cas connus : par exemple, si l’athlète a un record de 3 minutes sur “Fran”, le jumeau numérique devrait donner un temps approchant pour les paramètres correspondants. De même, on vérifie que les tendances sont respectées (ex : si on augmente le paramètre “fatigue” du matin, le temps simulé augmente ; si on améliore la VMA, le nombre de rounds en AMRAP 20 min augmente, etc.). On ajuste les coefficients du modèle de fatigue ou les paramètres du modèle ML tant que ces validations de bon sens ne sont pas satisfaites.
Clonage et variations : Une fois le modèle validé pour l’athlète de base, on génère des "clones" en variant légèrement ses paramètres. Par exemple, créer 5 clones avec ±5% sur le max de back squat, et 5 autres clones avec ±5% sur la VMA, ou toute autre combinaison pertinente (on peut aussi faire varier un paramètre de ressenti : un clone “fatigué” avec un score de fatigue plus élevé, un clone “reposé” avec une nuit parfaite, etc.). Chaque clone est une nouvelle instance d’Athlete avec ses propres valeurs. L’idée est d’échantillonner autour de l’athlète de référence pour voir l’impact de ces variations.
Simulation de scénarios : Pour chaque clone, on exécute la simulation du WOD (ou la prédiction ML). Si plusieurs WODs différents sont à l’étude (par ex. un WOD court très lourd et un WOD long d’endurance), on peut tous les tester afin de voir lequel met en avant telle ou telle qualité. C’est également ici qu’on peut tester différentes stratégies : par exemple, on peut simuler le clone A avec la stratégie “unbroken” (faire les répétitions sans pause tant que possible) puis re-simuler le même clone A avec une stratégie “prudente” (pauses régulières dès le début), et comparer les deux issues. En multipliant ainsi les scénarios, on obtient une matrice de résultats (chaque clone × chaque stratégie × chaque WOD).
Analyse des performances : On consolide tous les résultats de simulation dans une structure (par ex. un DataFrame pandas) où chaque ligne indique le clone, le WOD, la stratégie et le résultat (temps ou score). On peut alors facilement filtrer/ordonner pour trouver les meilleures performances. Supposons que sur un WOD donné, le clone qui a le mieux réussi est celui avec +5% de VMA et -5% de force par rapport à l’athlète réel, en utilisant une stratégie negative split (partir lentement puis accélérer) – cela suggère que l’athlète gagnerait à améliorer son endurance et à adopter un pacing plus conservateur en début de WOD. Ce type de conclusion se dégage en identifiant le clone optimal et en interprétant ses caractéristiques par rapport à l’athlète initial. L’analyse peut également passer par des méthodes quantitatives, par ex. calculer la corrélation entre chaque paramètre et la performance obtenue parmi les clones, ou entraîner un petit modèle (ex: arbre de décision) sur les résultats simulés pour extraire quels facteurs différencient les meilleurs clones des autres.
Visualisation des résultats (comparaison des clones)
La visualisation aidera à communiquer et comprendre les différences de performance entre clones et stratégies. Quelques idées de représentations graphiques en Python :
Comparaison des scores/temps : Un graphique en barres groupées peut afficher, pour chaque clone, le temps réalisé sur chaque WOD simulé. On verra ainsi immédiatement quel clone est le plus rapide. De même, pour un WOD de type AMRAP, on peut tracer une barre représentant le nombre de répétitions ou de tours accomplis par chaque clone. Ce type de visualisation met en évidence l’impact des variations de paramètres sur la performance brute finale.
Courbes de rythme et de fatigue : Pour analyser les stratégies, on peut tracer des courbes temporelles. Par exemple, une courbe montrant l’évolution du nombre de répétitions réalisées au cours du temps pour différents clones (ou différentes stratégies) sur un même WOD. Imaginons un 20 min AMRAP : on peut visualiser le nombre de tours complétés au fil des minutes. Un clone qui part trop vite pourrait avoir une courbe qui plafonne vers 15 minutes (il s’épuise et ralentit), alors qu’un clone qui gère mieux son effort aura une courbe plus linéaire jusqu’à 20 min. On peut aussi tracer la fréquence cardiaque simulée ou un indice de fatigue au cours du WOD si le modèle le prévoit, afin de voir à quel moment chaque clone atteint ses limites. Ces visualisations dynamiques aident à comprendre comment la performance finale est obtenue, au-delà du simple chiffre.
Heatmaps et diagrammes radar : Si l’on souhaite explorer l’effet de deux variables simultanément, les heatmaps sont utiles. Par exemple, on peut créer une matrice colorée dont l’axe X serait la température et l’axe Y l’humidité, et la couleur représenterait la performance simulée d’un même athlète dans ces conditions – on verrait ainsi dans quelle mesure chaque facteur de contexte détériore le score (zone rouge = conditions très pénalisantes)
trainingpeaks.com
. Un autre exemple : un radar chart (toile d’araignée) permettant de comparer le profil de plusieurs clones en un coup d’œil (ex : on trace pour l’athlète réel et pour le clone optimal leurs valeurs normalisées de force, endurance, fatigue, technique…, et on ajoute une dimension “performance” dans le radar pour voir lequel a l’aire la plus étendue). Cela donne une représentation visuelle directe des différences de profil.
Tableaux de bord interactifs : Pour faciliter l’exploration, on peut développer un petit tableau de bord avec Plotly Dash ou Streamlit. Cela permettrait à l’utilisateur (coach ou athlète) de sélectionner un WOD et d’ajuster des curseurs correspondant aux paramètres (par ex. simuler l’effet si la température monte à 30 °C, ou si l’athlète améliore son back squat de +10 kg) et de voir en temps réel la prédiction de performance. On peut imaginer un graphique se mettant à jour pour montrer la comparaison avant/après. Ce type d’outil interactif rend le jumeau numérique très concret à utiliser pour tester différents scénarios “et si ?”.
En combinant ces différentes visualisations, on obtiendra une compréhension approfondie des résultats. L’athlète et son entraîneur pourront identifier non seulement quel clone (donc quelles caractéristiques) performe le mieux, mais aussi pourquoi – par exemple, en voyant qu’une certaine stratégie évite un effondrement en fin de WOD, ou qu’une légère amélioration en endurance apporte plus de bénéfice qu’une grosse amélioration en force sur tel type d’épreuve. Cette approche guidée par la donnée permettra d’orienter l’entraînement (sur quels paramètres travailler en priorité) et d’optimiser la stratégie le jour de la compétition. Sources : Lim & Song (2023) – Performance prediction en CrossFit via machine learning
preprints.org
; Meier et al. (2023) – Revue systématique des facteurs de performance en CrossFit
pubmed.ncbi.nlm.nih.gov
pubmed.ncbi.nlm.nih.gov
; Martinez-Gomez et al. (2020) – Predictors of CrossFit Open performance
mdpi.com
; Serafini et al. (2018), Bellar et al. (2015), Feito et al. (2018) – études sur corrélats de performance (force vs endurance vs expérience)
mdpi.com
mdpi.com
; Dataset Kaggle CrossFit Athletes
lightningchart.com
; Blog TrainingPeaks – Impact de la chaleur et humidité sur l’exercice
trainingpeaks.com
; Blog SkratchLabs – Effets de l’altitude sur la performance
skratchlabs.com
.






Sources
Vous avez dit :
Mon objectif c'est de pouvoir faire des plan de pacing, rep sur une compétition de crossfit complete (wod simple, ou 6 wods sur deux jours etc ...), tester en changeant des paramètres lancer des clones virtuelle et trouver la stratégie la plus pertinente 
ChatGPT a dit :
Merci pour la précision. Pour que je t’aide à concevoir ou identifier les bons outils pour faire des plans de pacing et simuler une compétition complète avec des clones virtuels, pourrais-tu préciser :

Souhaites-tu simuler toute une compétition de CrossFit avec enchaînement de plusieurs WODs sur 1 à 3 jours (avec récupération, fatigue accumulée, etc.) ?

Veux-tu automatiser la génération des plans de pacing (nb de reps, pauses, cadence) ou juste tester manuellement des scénarios ?

Es-tu intéressé par un modèle Python standalone, ou souhaites-tu intégrer ça dans une app (par ex. avec une interface Streamlit ou autre) ?

Cela me permettra de compléter les recommandations pour gérer le pacing et les effets de la fatigue sur plusieurs WODs.

Vous avez dit :
Le MVP c'est pacing pour un seul wod, après l'idée a la suite sera de faire des compèt complète, on peut automatiser, python seul suffit dans un premier temp
ChatGPT a dit :
Merci, c'est clair. Je vais rechercher les meilleures approches en Python pour créer un MVP de simulateur de pacing pour un seul WOD de CrossFit. L’objectif est de pouvoir modéliser un athlète avec ses paramètres (force, endurance, fatigue, etc.), générer des clones en modifiant certains paramètres ou stratégies, et automatiser la simulation de pacing (découpage des reps, gestion des pauses, cadence) pour identifier la stratégie la plus pertinente sur ce WOD.

Je reviens vers toi avec des ressources, des approches concrètes de modélisation, et des exemples de structure de code en Python.

Research completed in 8m· 12 sources· 97 recherches
Simulateur de pacing pour un WOD de CrossFit avec clones en Python

Simulation du plan de pacing d’un WOD CrossFit en Python (MVP)
Modélisation du WOD et de sa structure
Pour commencer, il faut une représentation formelle du WOD (Workout of the Day) dans le code. Un WOD peut avoir différents formats : For Time (effectuer un travail complet le plus vite possible), AMRAP (Autant de répétitions que possible en un temps donné), ou autres variantes (EMOM, etc.). On peut modéliser un WOD comme une structure de données décrivant la séquence d’exercices, leur volume et d’éventuelles contraintes de temps :
Format For Time : Une liste ordonnée de tâches à accomplir. Par exemple, pour un WOD For Time on pourra représenter chaque segment comme un tuple (exercice, nombre_de_réps, charge). S’il y a des rounds, on peut soit déplier la liste (3 rounds de {20 thrusters, 15 pull-ups} deviennent la séquence thruster, pull-up, thruster, pull-up, etc.), soit conserver une notion de round (ex : une liste de rounds, chaque round contenant la liste de ses exercices). L’important est de pouvoir itérer sur chaque répétition à effectuer.
Format AMRAP : Ici on a une durée limite (time cap) et souvent un ensemble d’exercices à répéter en boucle. On peut représenter un AMRAP par la durée maximale et la liste des exercices constituant un cycle. Par exemple, un AMRAP 12 minutes de {10 burpees, 15 kettlebell swings} sera défini par duree_max=720s et cycle=[("burpee", 10), ("KB swing", 15)]. La simulation devra boucler sur le cycle jusqu’à épuiser les 12 minutes.
Autres formats : On peut prévoir une extensibilité pour d’autres formats (EMOM, HIIT en intervalles, etc.), mais pour un MVP on peut se concentrer sur For Time et AMRAP, qui couvrent déjà beaucoup de cas.
Il est judicieux d’encapsuler ces informations dans une classe WOD ou une structure de données dédiée. Par exemple :
class WOD:
    def __init__(self, format, tasks, time_cap=None):
        self.format = format  # e.g. "ForTime" ou "AMRAP"
        self.tasks = tasks    # liste de tuples (exercice, reps, charge) pour ForTime, 
                              # ou liste de tuples pour un cycle dans AMRAP
        self.time_cap = time_cap  # (pour AMRAP, en secondes)
Ainsi, on pourra écrire du code générique du type wod.simulate(athlete, strategy) qui parcourt wod.tasks en fonction du format. Par exemple, si format == "ForTime", on itère une fois sur chaque tâche; si format == "AMRAP", on répète les tâches en boucle jusqu’à atteindre time_cap. Cette abstraction rend le simulateur flexible pour différents types de WOD.
Modélisation de l’athlète et paramètres physiques
Ensuite, on définit un modèle simplifié de l’athlète avec ses caractéristiques physiques et contextuelles. On peut créer une classe Athlete avec des attributs tels que :
Force maximale (par exemple 1RM sur certains mouvements clés, comme le squat, le deadlift, le snatch, etc., ou une force générale pour poids du corps). Cela servira à estimer la difficulté relative d’un exercice avec charge pour l’athlète.
Endurance musculaire (capacité à enchaîner des répétitions d’un mouvement avant d’avoir une défaillance locale) et endurance cardiovasculaire (capacité aérobie, potentiellement reflétée par la VMA – vitesse maximale aérobie). Ces paramètres influenceront la vitesse d’exécution soutenable sur des efforts longs.
Fatigue initiale ou fraîcheur (par exemple un coefficient de fatigue accumulée avant le WOD, si on veut simuler un athlète déjà fatigué par une épreuve précédente).
Poids corporel (peut influer sur les mouvements gymniques ou la dépense énergétique).
Capacité de récupération (vitesse à laquelle l’athlète récupère quand il prend une pause).
En plus de ces attributs, l’athlète peut avoir des données empiriques de performance : par exemple, le temps moyen pour une répétition de tel exercice lorsqu’il est frais, ou son nombre maximal de répétitions unbroken (max set) sur certains mouvements (pull-ups, thrusters à 40kg, etc.). Ces données peuvent soit être fournies, soit estimées à partir des attributs ci-dessus. Exemple : on peut estimer le temps de base par répétition pour un mouvement donné. Pour un athlète donné, une répétition de thruster à 40 kg pourrait prendre 2 secondes s’il est en pleine forme. En revanche, une traction (pull-up) pourrait ne prendre que 1 seconde chacune au début. Ces valeurs de base peuvent être stockées dans l’objet Athlete (éventuellement dans un dictionnaire par type d’exercice). Enfin, pour interagir avec la simulation, la classe Athlete peut fournir des méthodes utilitaires comme temps_par_rep(exercice, charge, fatigue) et fatigue_par_rep(exercice, charge). Ces méthodes utilisent les paramètres de l’athlète pour calculer combien de temps prend une rep dans l’état actuel, et de combien la fatigue augmente quand il la réalise (voir section suivante).
Modèle de fatigue simplifié
La fatigue est un élément crucial à modéliser pour rendre la simulation réaliste. Un modèle de fatigue simplifié peut fonctionner avec un indicateur scalaire de fatigue globale qui évolue pendant le WOD. L’idée est de simuler que plus l’athlète enchaîne d’efforts, plus il ralentit ou a besoin de pauses. Pourquoi un modèle de fatigue ? Parce que la relation entre effort et performance n’est pas linéaire : si un athlète planifie simplement ses splits de manière arithmétique (ex: “faire un round toutes les 2 minutes”), cela ne tiendra pas compte de la dégradation physiologique au fil de l’effort
wodprep.com
. En réalité, la fatigue est multifactorielle et non linéaire, et la performance réelle déviera d’un plan trop rigide
wodprep.com
. C’est pour cela qu’on introduit une composante fatigue dans la simulation. Proposition de modèle : On peut représenter la fatigue par une variable continue fatigue (qui pourrait aller de 0 à 1 ou au-delà sans forcément de maximum fixe). Quelques règles simples :
Au début du WOD, fatigue = 0 (athlète frais).
Chaque répétition effectuée augmente la fatigue en fonction de l’intensité de l’exercice : par exemple, pour une rep, on ajoute Δfatigue = coeff_intensite * (charge / force_max) pour un exercice de musculation, ou un Δfatigue constant pour un mouvement de poids du corps/cardio. Un exercice très lourd pour l’athlète (charge proche de son max) induira une montée de fatigue plus forte. Un exercice léger ou cardio peut avoir un coefficient de fatigue moindre par rep, mais sur la durée (beaucoup de reps) ça finit aussi par fatiguer.
La fatigue accumulée peut ralentir les répétitions suivantes. Par exemple, on peut modéliser le temps d’une rep comme temps_rep = temps_base * (1 + alpha * fatigue_actuelle). Ainsi, plus fatigue_actuelle est élevée, plus chaque rep prend de temps. Le coefficient alpha pourrait être calibré selon l’athlète (par ex, un athlète avec une meilleure endurance a un alpha plus faible, donc sa perte de vitesse sous fatigue est moindre).
La fatigue peut diminuer pendant les pauses (récupération). On peut modéliser une récupération simple : par exemple, à chaque seconde de repos, réduire la fatigue d’un certain pourcentage ou d’une valeur fixe. Une approche simple est de décréter qu’une pause de t secondes fait baisser la fatigue de beta * t (borné à revenir vers 0 asymptotiquement, sans devenir négative). Ou bien utiliser une formule de récupération exponentielle (rapide au début puis ralentissant).
On gardera ce modèle relativement simple pour le MVP, quitte à l’affiner plus tard. Par exemple, on n’aura peut-être qu’une seule dimension de fatigue, sans distinguer fatigue musculaire locale vs fatigue cardiovasculaire, mais on peut ajuster Δfatigue par rep selon le type d’exercice pour refléter un peu ces différences. Exemple concret : supposons un athlète qui effectue des thrusters. À chaque thruster, on augmente fatigue de 0,02 (s’il est très endurant) ou 0,05 (s’il l’est moins) et chaque rep prend temps_base_thruster * (1 + fatigue). Au début, si fatigue=0 et temps_base_thruster=2s, la première rep prend ~2s. Si après quelques reps la fatigue vaut 0,5, alors une rep prend 2 * (1+0,5) = 3s. On voit que le modèle force une diminution de cadence. On peut plafonner la fatigue ou moduler son effet, mais l’idée générale est là : plus on accumule de fatigue, plus on ralentit à moins de prendre des pauses. Notons que ce modèle peut être enrichi de règles ad hoc. Par exemple, on peut décider qu’au-delà d’un certain seuil de fatigue, l’athlète doit prendre une pause (par exemple s’il atteint fatigue = 1.0, il est “dans le rouge” et ne peut plus continuer sans repos). Cela peut être implémenté en surveillant la variable et en forçant une pause quand le seuil est atteint (voir la partie stratégie).
Logique de pacing et stratégies de rythme
C’est ici qu’intervient la notion de stratégie de pacing : comment l’athlète décide d’enchaîner les répétitions et rounds, c’est-à-dire la répartition de l’effort dans le temps. Différentes stratégies peuvent être simulées, par exemple :
Tout unbroken vs fractionné : Unbroken signifie faire une série de répétitions sans aucune pause jusqu’au bout. Fractionner consiste à diviser une série en plusieurs sets avec des pauses programmées. Par exemple, sur 21 pull-ups, un athlète peut choisir 21 unbroken (tout d’une traite) ou fractionner 11-10 (faire 11, prendre une courte pause, puis les 10 restantes). La simulation doit permettre de tester ces scénarios et voir l’impact sur le temps total. En général, aller unbroken maximise la vitesse initiale mais risque d’induire une fatigue très élevée obligeant à de longues pauses plus tard, tandis que fractionner tôt permet de retarder l’accumulation de fatigue et de maintenir un rythme plus soutenu sur la durée. Les coachs expérimentés conseillent souvent de ne pas aller jusqu’à l’échec musculaire sur un set : un bon repère est de ne pas dépasser ~50% de son max unbroken dans une série de WOD
wodprep.com
. Par exemple, si je sais faire 10 pull-ups maximum d’un coup à froid, en WOD je ne devrais pas en faire plus de 5 d’affilée avant de me reposer. Mieux vaut “garder deux reps sous le pied” plutôt que de faire la rep de trop qui fait exploser
wodprep.com
.
Taille des sets et descente de répétitions : Une stratégie efficace est de faire des sets dégressifs plutôt qu’égaux. Par exemple pour 15 reps, faire 6-5-4 au lieu de 5-5-5
wodprep.com
. Le premier set, fait à fraîcheur relative, est plus gros, puis on réduit le volume à mesure que la fatigue monte, ce qui permet de maintenir des temps de récupération plus courts et un rythme global élevé. Cette logique peut être intégrée en définissant, pour chaque exercice, un schéma de fractionnement. Pour le MVP, on peut coder quelques schémas fixes (tout unbroken, ou bien fractionner en X sets égaux, ou fractionner en sets dégressifs prédéfinis). Plus tard on pourra générer ces schémas automatiquement en fonction du max de l’athlète, mais pour démarrer on peut tester manuellement quelques options raisonnables.
Rythme constant vs décrochage (positive vs negative split) :
Stratégie “rythme constant”: l’athlète essaye de maintenir un temps par round constant du début à la fin. En pratique, cela signifie partir prudemment pour ne pas se brûler, afin que le dernier round soit proche du premier en durée. C’est souvent la stratégie optimale sur des efforts d’endurance modérés. D’ailleurs, une étude sur les compétiteurs CrossFit a montré que le meilleur prédicteur de la performance sur des WOD multi-rounds était la capacité à tenir un rythme moyen élevé sans trop faiblir – en clair, ceux qui maintiennent des rounds réguliers et rapides finissent devant ceux qui s’effondrent sur la fin
pmc.ncbi.nlm.nih.gov
. La même étude indique que pour un WOD à rounds multiples, un rythme “rapide mais tenable” tout du long maximise le score, alors qu’un départ trop rapide qui cause un effondrement ensuite est sous-optimal
pmc.ncbi.nlm.nih.gov
.
Stratégie “décroissante” (positive split) : c’est le scénario où l’athlète part très fort et ralentit ensuite de plus en plus. C’est souvent ce qui arrive quand on va “all-out” dès le début, et ce n’est généralement pas optimal, sauf sur des WOD très courts. Par exemple, si on compare All-out vs Pacing contrôlé : une recherche en 2024 a comparé une stratégie à fond dès le début contre une stratégie contrôlée sur les 2 premiers rounds puis sprint final sur un WOD standard (Fight Gone Bad). La stratégie contrôlée a fait moins de répétitions au 1er round (99 vs 114) mais en a fait beaucoup plus aux 2e et 3e rounds (98 vs 80, puis 97 vs 80), finissant avec un total bien supérieur à la stratégie all-out
pubmed.ncbi.nlm.nih.gov
. Cela illustre qu’un départ trop rapide mène à une fatigue précoce qui plombe la performance sur la suite, alors qu’un pacing plus modéré au début permet de garder un volume élevé plus tard.
Stratégie “negative split”: c’est l’inverse du précédent – partir volontairement en dessous de son rythme optimal puis accélérer chaque round. En course à pied on parle de negative split quand la seconde moitié est plus rapide que la première. En CrossFit cela peut être payant sur des WOD d’endurance metabolique sans points de fatigue musculaire limitants. Par exemple, sur un AMRAP 12 minutes de burpees et rameur, un athlète pourrait décider de faire les 4-5 premières minutes en dedans puis d’accélérer progressivement pour finir très fort. Tenir ce pari nécessite beaucoup de sang-froid car il faut résister à l’envie de partir vite. C’est à réserver aux WODs “monostructurés” ou cycliques simples
wodprep.com
wodprep.com
. Pour le modéliser, on peut introduire une stratégie où le temps par rep visé diminue au fil du temps (ou bien où l’athlète conserve de l’énergie au début en choisissant des fractions plus petites que nécessaire, puis augmente ses sets plus tard).
Gestion des pauses programmées : Au lieu de subir la fatigue jusqu’à devoir s’arrêter net, un athlète peut choisir de prendre des micro-pauses régulières dès le début. Par exemple, décider de respirer 5 secondes tous les 10 thrusters même s’il se sent encore bien. Ceci peut être représenté dans la stratégie par des règles du type : “toutes les X répétitions de tel mouvement, insérer une pause de Y secondes”. Cette approche permet une récupération partielle fréquente, évitant que la fatigue atteigne des sommets. Notre simulateur devrait permettre de paramétrer de telles pauses planifiées. On peut même faire varier la durée des pauses en cours de WOD (ex: 5s au début de chaque 10 reps, puis si on voit la fatigue quand même monter trop, passer à 8s). Pour MVP on peut rester sur des pauses fixes prédéfinies dans la stratégie.
Pour implémenter ces stratégies, plusieurs approches sont possibles. Une classe Strategy pourrait contenir les paramètres réglant le pacing : par exemple Strategy(unbroken=True) ou des champs plus précis du genre max_reps_before_break={"thruster": 10, "pull-up": 5}, planned_rest={"thruster": 5, "pull-up": 3} (en secondes), etc. Alternativement, on peut coder la logique de pacing directement dans la boucle de simulation en branchant sur des conditions (ex: si strategie == "unbroken" alors ne s’arrêter que quand on doit, sinon si strategie == "fractionneX" appliquer tel schéma). Pour garder la simulation évolutive, il est mieux d’externaliser ces règles soit dans un objet stratégie, soit dans des fonctions de callback (par ex, passer une fonction pause_decision(athlete, exercise, rep_count, fatigue) qui retourne True/False ou une durée de pause à prendre). À retenir : l’objectif est de pouvoir tester facilement plusieurs stratégies sur un même WOD et un même athlète. La structure de code doit permettre d’alterner la stratégie appliquée sans tout réécrire. Par exemple, on peut écrire : simulate(wod, athlete, strategy) où strategy encapsule les décisions de pacing (quand se reposer, combien de reps par set, etc.).
Simulation du déroulement du WOD
Avec tous les éléments ci-dessus (représentation du WOD, athlète, fatigue, stratégie), on peut coder le moteur de simulation. L’idée générale est de parcourir chaque rep du WOD dans l’ordre chronologique, en incrémentant un compteur de temps et en modifiant l’état de l’athlète (fatigue) au fur et à mesure. Voici un pseudocode simplifié pour un WOD For Time :
temps_total = 0.0
fatigue = 0.0
for (exercice, reps, charge) in wod.tasks:            # parcourir chaque tâche du WOD
    for rep in range(1, reps+1):                      # boucle sur chaque rep individuelle
        # Décision de pause avant cette rep ?
        if strategy.doit_prendre_pause(exercice, rep, fatigue):
            pause_duree = strategy.duree_pause(exercice, fatigue)
            temps_total += pause_duree
            # récupérer pendant la pause (réduire fatigue)
            fatigue = max(0.0, fatigue - strategy.recupération(pause_duree, fatigue))
        # Effectuer la rep
        temps_rep = athlete.temps_par_rep(exercice, charge, fatigue)
        temps_total += temps_rep
        # Accumuler la fatigue due à cette rep
        fatigue += athlete.fatigue_par_rep(exercice, charge)
        # Optionnel: sécurité pour ne pas dépasser un certain fatigue max
    # (éventuellement gérer la transition entre exercices, e.g. ajouter quelques secondes de transition)
# Fin du WOD For Time, on a le temps total
print(f"Temps total réalisé : {temps_total:.1f} secondes")
Plusieurs détails peuvent être ajoutés dans cette boucle :
Temps de transition entre exercices ou entre stations (par exemple, 5 secondes pour attraper un autre équipement, etc.) si on veut être réaliste. On peut soit les inclure comme une étape exercice="transition" dans le WOD, soit les ajouter dès qu’on change d’exercice. Pour MVP on peut ignorer ou fixer un petit temps constant de transition.
Gestion de la fin d’un AMRAP : si format == "AMRAP", il faut interrompre la boucle dès que temps_total dépasse time_cap. Cela implique de vérifier à chaque rep si on ne va pas dépasser le temps imparti. On pourrait aussi calculer a priori combien de cycles complets rentrent, mais mieux vaut le simuler pour capturer aussi un cycle partiel (ex: le temps s’écoule au milieu d’un cycle).
La fonction strategy.doit_prendre_pause peut implémenter différentes logiques en fonction de la stratégie courante : par exemple, si l’athlète a prévu des pauses toutes les 10 reps, ou dès que la fatigue dépasse 0.5, etc. Dans une implémentation simple, on peut combiner les deux : prendre une pause si on a atteint le nombre de reps voulues dans le set ou si la fatigue dépasse un seuil critique. De même, strategy.duree_pause peut être une constante prédéfinie (par ex 5 secondes) ou dépendre de l’état (ex: plus la fatigue est élevée, plus on prend une longue pause). Exemple de logique dans la boucle : Supposons une stratégie où l’on fractionne les thrusters en sets de 10 reps avec 5s de pause : la fonction doit_prendre_pause("thruster", rep, fatigue) retournera True pour rep=11,21,... ou si fatigue est trop haute avant même d’atteindre 10 reps. Au moment de la pause, duree_pause retournera 5s. La fatigue pendant la pause sera réduite, par exemple fatigue = fatigue * 0.5 (on récupère 50% de la fatigue accumulée en 5s – c’est un choix arbitraire). Après avoir simulé chaque rep ainsi, à la fin d’un WOD For Time on obtient temps_total qui est le time cap réalisé. Pour un AMRAP, on peut calculer le nombre total de reps effectuées (il faudrait incrémenter un compteur de reps tant qu’on est dans le temps imparti). On pourrait également collecter d’autres stats durant la sim (ex: temps par round, pic de fatigue, etc.) pour analyse plus fine. Cette simulation peut être vérifiée sur des cas simples pour valider le modèle. Par exemple, on peut tester un WOD avec un seul exercice et comparer unbroken vs fractionné : le modèle devrait montrer qu’en unbroken on finit plus vite au début mais avec une grosse pause forcée ensuite, tandis que fractionné on prend plus de pauses mais on ne s’effondre pas en performance. Ces différences devraient se refléter dans le temps_total. On pourra ajuster les paramètres de fatigue pour coller à l’intuition ou à des données réelles si on en a.
Génération de clones et comparaison des performances
Une fois qu’on peut simuler un athlète et une stratégie sur un WOD, on veut automatiser la création de “clones” pour tester des variantes. Il s’agit soit de clones de l’athlète (modifier ses paramètres physiques) soit de clones de stratégie (changer la tactique) – ou les deux. Le but est de comparer leurs résultats pour identifier la meilleure approche. Clones d’athlète : on peut créer des variantes de l’athlète original en faisant varier un ou plusieurs paramètres de ±X%. Par exemple, générer un clone avec +5% en endurance, un autre avec -5% en endurance, un avec +5% en force, etc. Chaque clone représente le même athlète légèrement différent (plus fort, plus faible, plus endurant, etc.). En simulant le même WOD pour ces clones (idéalement avec la même stratégie de base), on peut voir quels paramètres influent le plus sur le score. Par exemple, si le clone +5% endurance gagne 30 secondes sur le temps final, c’est que l’endurance était un facteur limitant important. Cela peut orienter l’athlète vers quel axe travailler, ou simplement servir à sensibiliser sur l’impact de chaque caractéristique. Clones de stratégie : de même, on peut définir plusieurs stratégies à tester. Par exemple : stratégie_A = tout unbroken, stratégie_B = fractionné 10-10-... avec pauses courtes, stratégie_C = fractionné 5-5-5-... avec pauses courtes, stratégie_D = départ lent puis accélération (negative split), etc. On clone la configuration de l’athlète inchangée, mais on change la façon dont il gère son effort. En simulant toutes ces stratégies, on obtient différents résultats (temps final ou score AMRAP). On pourra identifier laquelle donne la meilleure performance. Par exemple, on pourrait constater que l’athlète termine en 12:00 en unbroken, 11:30 en fractionné descendant (ex : 10-8-7 reps) et 12:30 en fractionné fixe (5-5-5-5-5...). On en déduit que la stratégie descendante était la plus efficace pour lui sur ce WOD. Cette démarche teste virtuellement des pacing plans sans avoir à les réaliser physiquement, ce qui est très précieux pour l’athlète. En pratique, les coachs savent empiriquement que faire des sets dégressifs et ne pas atteindre l’échec est souvent gagnant
wodprep.com
, et notre simulateur peut le vérifier quantitativement. Automatisation : pour générer ces tests en masse, on peut simplement coder des boucles qui énumèrent les cas. Par exemple :
strategies = [strategie_A, strategie_B, ...]
athlete_variants = [athlete_base.clone(modifs) for modifs in liste_modifications] 

for strat in strategies:
    for ath in athlete_variants:
        resultat = simulate(wod, ath, strat)
        stocker_resultat(ath, strat, resultat)
On stocke les résultats (par ex. dans une liste ou un DataFrame pandas) avec l’identifiant du clone et de la stratégie, et le score obtenu. Ensuite, on peut trier ou filtrer pour trouver le meilleur temps. Si le but est de trouver la meilleure stratégie pour l’athlète donné, on gardera l’athlète fixe et on comparera les résultats par stratégie. Si le but est d’explorer l’espace des paramètres physiques, on peut garder la stratégie fixe. On peut bien sûr faire les deux séparément. Pour interpréter les résultats, quelques méthodes utiles :
Calculer l’écart de performance entre stratégies (ex: stratégie B est 5% plus rapide que A).
Identifier à partir de quel point la stratégie all-out devient moins efficace (ex: on voit que tel athlète en all-out gagne le 1er round de 15s mais perd 30s sur les deux rounds suivants comparé à pacing modéré, ce que montrait l’étude scientifique
pubmed.ncbi.nlm.nih.gov
).
Visualiser éventuellement la courbe de fatigue ou le temps par segment pour chaque stratégie : par exemple, on pourrait tracer fatigue vs temps ou temps cumulé après chaque round pour chaque simulation, afin de voir comment la courbe diffère selon la tactique. Dans une stratégie optimale on s’attend à une courbe plus “lisse”, sans rupture brutale due à une pause forcée trop longue.
Le MVP pourrait se contenter d’afficher les temps finals ou scores, mais l’extensibilité du simulateur permettra d’approfondir ces analyses.
Suggestions de structure de code modulaire
Organiser le code avec des classes Python peut grandement améliorer la clarté et la maintenabilité de cette simulation. Voici une structure possible résumée :
Classe Athlete : contient les paramètres de l’athlète et éventuellement des méthodes utilitaires. Par exemple:
class Athlete:
    def __init__(self, strength, endurance, vma, fatigue_resistance, weight):
        self.strength = strength
        self.endurance = endurance
        # ... autres paramètres ...
        # on peut ajouter un dict pour temps de base par exo : 
        self.base_pace = {"thruster": 2.0, "pull-up": 1.0, ...}  # en secondes par rep
    def temps_par_rep(self, exercice, charge, fatigue):
        base = self.base_pace.get(exercice, 1.0) 
        # ajuster base en fonction de la charge relative à la force max:
        if charge:
            intensite = charge / self.strength.get(exercice, charge)  # ratio par rapport à 1RM estimé
        else:
            intensite = 0.5  # exo poids du corps par exemple
        # exemple: plus l'intensité est grande, plus la rep de base est lente
        base_effectif = base * (1 + 0.5*intensite)  
        # puis appliquer l'effet de la fatigue:
        return base_effectif * (1 + fatigue * 0.3)  # 0.3 = alpha, coefficient fatigue
    def fatigue_par_rep(self, exercice, charge):
        # retourne combien on augmente la fatigue pour 1 rep de cet exercice
        # on peut utiliser endurance et intensité
        intensite = charge / self.strength.get(exercice, charge) if charge else 0.5
        return 0.01 + 0.05 * intensite  # par ex., base 0.01 + proportionnel à intensité
Remarque: le code ci-dessus est purement indicatif pour montrer comment utiliser les paramètres. Il faudra calibrer les formules pour que la simulation soit cohérente (on peut ajuster ces coefficients après quelques tests).
Classe WOD : comme décrit précédemment, stocke le format, la liste des tâches, et éventuellement une méthode simulate(athlete, strategy) qui encapsule la boucle de simulation. On peut aussi mettre la boucle à l’extérieur, auquel cas WOD ne sert qu’à fournir les données.
Classe Strategy : encapsule la logique de pacing. Par exemple:
class Strategy:
    def __init__(self, breaks=None, max_set=None, pace_profile=None):
        # breaks: dict mapping exercise -> (reps_before_break, break_duration)
        # max_set: dict mapping exercise -> reps max par set (peut redondant avec breaks)
        # pace_profile: e.g. "negative_split" or custom function for target pace by round
        self.breaks = breaks or {}
        self.max_set = max_set or {}
        self.pace_profile = pace_profile
    def doit_prendre_pause(self, exercice, rep_courante, fatigue):
        if exercice in self.breaks:
            reps_before, _ = self.breaks[exercice]
            if (rep_courante-1) % reps_before == 0 and rep_courante > 1:
                return True
        # on pourrait ajouter: if fatigue > X: return True
        return False
    def duree_pause(self, exercice, fatigue):
        if exercice in self.breaks:
            _, pause_dur = self.breaks[exercice]
            return pause_dur
        return 0
    def recuperation(self, duree_pause, fatigue):
        # fraction de fatigue récupérée pendant la pause
        # par exemple: récupérer 20% de la fatigue par seconde de pause, plafonné à tout récupérer
        return min(fatigue, 0.2 * duree_pause * fatigue)
Ceci est un exemple minimal : on peut imaginer des stratégies plus complexes avec une pace_profile qui influe sur l’allure cible par round (pour implémenter un negative split, etc.). Mais déjà, breaks et max_set permettent de modéliser pas mal de choses (un max_set peut servir à ne pas dépasser X reps unbroken pour un mouvement donné, complémentaire au schéma de break).
Fonction de simulation principale : on peut avoir une fonction libre simulate_wod(wod, athlete, strategy) qui réalise la boucle comme décrite plus haut et renvoie le résultat (temps ou score). Alternativement, intégrer cette fonction comme méthode WOD.simulate(athlete, strategy) pour regrouper. Le choix est stylistique. Pour un MVP, une fonction globale est très bien aussi.
Collecte des résultats : éventuellement une structure pour stocker et comparer les simulations. Par exemple, une liste de tuples (athlete_variant, strategy, result) ou mieux, un DataFrame pandas pour bénéficier des fonctionnalités de tri/filtre.
Avec cette organisation, ajouter un nouveau type de stratégie ou un nouveau paramètre d’athlète est relativement localisé (on touche seulement la classe concernée sans affecter le reste). Cela facilitera l’extension à plusieurs WODs plus tard : on pourrait boucler sur une liste de WODs (une compétition entière) et sommer les temps ou scores, ou simuler la fatigue résiduelle d’un WOD à l’autre (ce qui est un autre niveau de complexité – conserver une fatigue accumulée d’un événement à l’autre). Notre structure modulaire sera prête à accueillir ce genre d’évolution.
Bibliothèques Python pertinentes
Pour réaliser ce simulateur MVP, les bibliothèques standard suffisent largement, mais certaines libs peuvent aider pour l’analyse des résultats ou la structuration du code :
dataclasses (Python 3.7+) : permet de définir les classes Athlete, WOD, Strategy de manière concise. En utilisant @dataclass, on obtient gratuitement des méthodes comme __init__ et une représentation propre, ce qui est pratique pour gérer de multiples clones.
NumPy : si on envisage de faire un très grand nombre de simulations (par exemple pour explorer un grand espace de paramètres), l’utilisation de vecteurs NumPy pourrait accélérer certaines boucles numériques. Par exemple, on pourrait vectoriser le calcul de temps par rep sur un tableau de paramètres. Toutefois, pour un MVP avec un nombre raisonnable de clones, l’approche pure Python est probablement suffisante en termes de performance et plus simple à écrire.
Pandas : utile si on souhaite stocker les résultats de dizaines/centaines de simulations de clones et ensuite effectuer des filtres (par ex, sélectionner la meilleure stratégie pour chaque variante d’athlète, etc.). Un DataFrame permet de facilement comparer les temps ou d’appliquer des regroupements. De plus, Pandas offre des fonctions statistiques basiques si on veut moyenne, écart-type des performances, etc.
Matplotlib/Seaborn : pour visualiser les pacing profiles issus de la simulation. Par exemple, on peut tracer la courbe du temps cumulé par round pour chaque stratégie, ou la fatigue en fonction du temps. Cela peut révéler visuellement quelle stratégie est la plus équilibrée. Ce n’est pas indispensable pour le MVP, mais c’est un bonus appréciable pour interpréter les résultats.
SimPy (bibliothèque de simulation à événements discrets) : c’est un outil puissant pour des simulations complexes. On pourrait modéliser l’athlète comme un processus et chaque rep comme un événement. Cependant, dans ce cas spécifique, la logique séquentielle est assez simple, donc utiliser SimPy pourrait être excessif. Pour un MVP, un simple loop comme décrit suffit. SimPy deviendrait intéressant si on simule plusieurs athlètes en parallèle, des événements aléatoires, ou des ressources partagées – ce qui n’est pas vraiment le cas ici (un athlète fait son WOD seul).
Outils d’optimisation/IA (pour aller plus loin) : À terme, si l’on souhaite automatiser la recherche de la stratégie optimale sans tout tester manuellement, on pourrait intégrer des approches d’optimisation. Par exemple, utiliser un algorithme génétique ou une recherche bayésienne pour affiner les paramètres de pacing (taille des sets, durées de pause) et minimiser le temps final. On pourrait aussi modéliser le problème en environnement de renforcement (reinforcement learning) et laisser un agent apprendre la meilleure manière de répartir son effort. Ceci dépasse le cadre du MVP, mais la structure qu’on a posée pourrait servir de base à un environnement (état = fatigue, reps restantes, etc., actions = continuer ou pause, etc.) pour un agent entraîné. Il est bon de garder en tête cette extensibilité, mais initialement on peut se contenter d’une recherche exhaustive sur quelques stratégies définies manuellement étant donné que leur nombre est limité.
Conclusion et prochaines étapes
En résumé, pour développer un MVP de simulateur de pacing en Python, il convient de :
Définir clairement les données d’entrée : le WOD (structure d’exercices/reps), les capacités de l’athlète, et les paramètres de stratégie.
Implémenter la boucle de simulation pas-à-pas qui calcule la performance (temps ou score) en tenant compte de la fatigue accumulée et des décisions de pacing.
Tester et ajuster le modèle simplifié de fatigue pour qu’il soit cohérent avec la réalité (par exemple, vérifier que plus d’intensité = plus de fatigue = ralentissement notable, etc., sans toutefois produire des résultats absurdes). On peut se baser sur des observations empiriques pour calibrer (les conseils pratiques comme “prévoir du ralentissement sur chaque round”
wodprep.com
 peuvent guider les paramètres du modèle).
Générer des variantes afin de comparer et identifier la meilleure approche, que ce soit en termes de stratégie de course ou d’attributs athlétiques.
Ce simulateur, bien qu’assez simplifié, posera les bases d’un moteur de simulation qu’on pourra enrichir. À l’avenir, on pourra intégrer davantage de nuances : des modèles de fatigue plus poussés, la gestion de plusieurs WOD de suite (et donc de la récupération entre WODs), ou des événements imprévus. Les principes resteront les mêmes – modéliser l’athlète et le WOD, et simuler l’interaction entre les deux. Grâce aux résultats obtenus et aux citations de références, on sait déjà que maintenir un rythme soutenu et constant est clé dans la plupart des cas
pmc.ncbi.nlm.nih.gov
, et qu’une bonne stratégie peut faire la différence sur la performance finale sans changer les capacités physiques de l’athlète. Avec le code structuré proposé, on offre à l’utilisateur (coach ou athlète) un outil pour expérimenter virtuellement ces scénarios et trouver le pacing optimal pour un WOD donné. Les prochaines étapes consisteront à valider ce MVP sur des exemples concrets (par exemple, simuler un benchmark Fran ou Murph avec différentes stratégies) et à affiner le réalisme du modèle au regard des résultats attendus ou de données réelles, afin d’assurer que l’outil devienne un conseiller fiable pour la planification de pacing. Avec une telle fondation, il sera ensuite plus facile d’étendre la simulation à des compétitions entières, en simulant WOD après WOD, en gérant la fatigue résiduelle, et en continuant d’optimiser la stratégie sur plusieurs événements successifs. Sources : Pour élaborer ces recommandations nous nous sommes appuyés sur des principes de pacing reconnus et des études sur la performance en CrossFit. Par exemple, WODprep souligne l’importance de fractionner intelligemment les séries et d’anticiper la dégradation des temps par round due à la fatigue
wodprep.com
wodprep.com
. Des recherches empiriques confirment qu’un rythme soutenu et constant est généralement gagnant sur plusieurs rounds
pmc.ncbi.nlm.nih.gov
, et qu’un all-out initial se paie plus tard en termes de fatigue
pubmed.ncbi.nlm.nih.gov
. Ces éléments ont guidé la conception du modèle de fatigue et des stratégies de pacing du simulateur. En combinant ces données et une architecture logicielle modulaire, on obtient un outil MVP prêt à être codé en Python pour tester virtuellement différentes approches sur un WOD donné.
wodprep.com
pmc.ncbi.nlm.nih.gov




Sources
Vous avez dit :
J'ai envie d'avoir un truc propre en terme de code, maintenabilite, modularité, en tant que développeur senior propose moi le meilleur plan ? 
ChatGPT a dit :
Très bien. Pour que je puisse te proposer une architecture propre, maintenable et modulaire à la hauteur d’un développeur senior, peux-tu me préciser quelques points :

Souhaites-tu organiser cela comme une librairie Python réutilisable, ou comme un script unique / prototype pour commencer ?

Prévois-tu de faire des tests unitaires, ou souhaites-tu un squelette sans tests dans un premier temps ?

As-tu une préférence sur les outils ou structures (ex : Pydantic, dataclasses, typage strict, gestion des configs via YAML/JSON, etc.) ?

Souhaites-tu intégrer dès maintenant une CLI ou interface Streamlit ou te concentrer uniquement sur le moteur de simulation (core logic) ?

Avec ces réponses, je te proposerai une architecture modulaire, scalable et testable adaptée à un usage robuste sur le long terme.

Vous avez dit :
Une librarie python réutilisable serait peut être mieux ? J'aimerai tester avec moi et plusieurs autres athlètes pour tester, moi ainsi que mes amis connaissent déjà certaines de leur perf pour donner l'enveloppe,3 j'y connais rien .. streamlit paraît bien pour commencer a regarder interface 
ChatGPT a dit :
Parfait. Je vais te proposer une architecture propre et modulaire pour créer une librairie Python réutilisable dédiée à la simulation de pacing pour WOD CrossFit, avec une base robuste (dataclasses, typage fort, logique testable) et conçue pour accueillir à terme une interface Streamlit.

Je vais structurer la recommandation comme un vrai projet Python (ex: arborescence, fichiers, dépendances), avec des exemples concrets de composants, de logique métier, et une ouverture claire vers des tests unitaires ou des interfaces futures. Je reviens vers toi très bientôt avec un plan clair et professionnel.

Research completed in 7m· 19 sources· 78 recherches
Architecture propre pour une librairie Python de simulation de pacing CrossFit

Conception d’une librairie de simulation de pacing CrossFit
Structure du projet
Pour construire une librairie Python modulaire et maintenable, on propose une structure de projet claire en dossiers et fichiers. Un exemple d’arborescence pourrait être :
mon_projet_wod/
├── README.md                 # Documentation du projet
├── pyproject.toml / setup.py # Configuration d'installation du package
├── mywodlib/                 # Package Python de la librairie
│   ├── __init__.py
│   ├── athlete.py            # Module pour la classe Athlete
│   ├── workout.py            # Module pour la classe WOD (Workout)
│   ├── strategy.py           # Module pour les stratégies de pacing
│   ├── simulator.py          # Module de simulation du WOD
│   └── utils.py (optionnel)  # Utilitaires divers (ex: fonctions de clone, comparaisons)
└── tests/                    # Dossier des tests unitaires
    ├── test_athlete.py
    ├── test_workout.py
    ├── test_strategy.py
    └── test_simulator.py
Cette organisation sépare clairement les composants par responsabilité (athlète, entraînement, stratégie, simulation), conformément au principe qu’« chaque module devrait avoir une responsabilité unique et bien définie »
labex.io
. Le dossier mywodlib contient la librairie elle-même, tandis que tests/ regroupe les tests unitaires correspondants. On inclut également un fichier de configuration (pyproject.toml ou setup.py) pour pouvoir installer la librairie, un README.md documentant le projet, et éventuellement un fichier requirements.txt listant les dépendances de développement.
Modules et classes principales
Les principaux modules et classes à concevoir sont :
Athlete (athlete.py) : représente un athlète avec ses paramètres de performance. On y définit des attributs tels que la force maximale, l’endurance, la résistance à la fatigue, des performances de référence (PR) sur certains exercices, etc. Cette classe peut inclure des méthodes pour estimer la performance de l’athlète sur un effort donné (par ex. temps pour 100 burpees, nombre maximal de répétitions sans pause) en se basant sur ses paramètres. L’instance d’Athlete sert de modèle de base sur lequel la simulation s’appuie.
Workout (WOD) (workout.py) : modélise un WOD de CrossFit. Il définit la structure de l’entraînement, par exemple une liste d’exercices ou de rounds avec leurs répétitions, charges ou distances. Il comporte aussi le type de WOD (par exemple "For Time" où l’objectif est d’accomplir tous les exercices le plus vite possible, ou "AMRAP" – As Many Reps As Possible – où l’athlète fait un maximum de répétitions pendant une durée fixe). La classe WOD aura des attributs comme exercises (liste des exercices avec leurs détails), mode (type de WOD, e.g. "for_time" ou "amrap"), et éventuellement time_cap (durée limite si applicable). On peut prévoir une structure interne pour représenter chaque exercice (par ex. une petite classe ou dataclass Exercise avec le nom du mouvement, le nombre de répétitions ou la distance, la charge, etc.) afin de faciliter le parcours du WOD dans la simulation.
Strategy (strategy.py) : définit une stratégie de pacing pour réaliser le WOD. On peut concevoir une classe abstraite Strategy (interface) et plusieurs stratégies concrètes (par ex. EvenPacingStrategy, NegativeSplitStrategy, AllOutStrategy, etc.), ou bien une seule classe paramétrable. La stratégie indique comment l’athlète va fractionner les efforts et gérer ses pauses. Par exemple, pour un WOD donné, la stratégie pourrait spécifier que l’athlète fera des séries de 10 pull-ups avec 15 secondes de repos entre séries, ou qu’il adoptera un rythme constant du début à la fin. Ce module encapsule toutes les règles de pacing indépendamment de l’athlète, ce qui permet d’expérimenter facilement différentes approches.
Simulator (simulator.py) : contient la logique pour simuler l’exécution d’un WOD par un athlète donné selon une stratégie donnée. On peut implémenter une classe Simulator ou simplement une fonction de haut niveau (par ex. simulate(wod: WOD, athlete: Athlete, strategy: Strategy) -> Result). La simulation va itérer à travers les exercices du WOD, calculer le temps pris pour chaque segment en fonction des caractéristiques de l’athlète et de la stratégie (en gérant la fatigue croissante, les pauses imposées par la stratégie, etc.), et produire un résultat. Le résultat peut être encapsulé dans une classe Result (dataclass) contenant par exemple le temps total réalisé pour un WOD For Time ou le score (nombre de répétitions accomplies) pour un WOD de type AMRAP, ainsi que des détails utiles (temps par exercice ou par round, fatigue finale estimée, etc.).
Clonage et variations : il ne s’agit pas forcément d’un module séparé, mais la librairie doit permettre de générer facilement des variantes d’athlètes et de stratégies (“clones”) pour tester différents scénarios. Par exemple, on pourra créer plusieurs instances d’Athlete légèrement modifiées (un athlète de base et un clone avec +10% d’endurance, etc.), ou définir plusieurs stratégies différentes, puis utiliser le simulateur pour toutes les comparer. On peut prévoir des méthodes utilitaires pour cloner un athlète en modifiant certains attributs (par ex. une méthode Athlete.clone_with(**kwargs) qui retourne un nouvel athlète avec certains paramètres ajustés), ou tout simplement utiliser le constructeur/dataclass pour créer de nouvelles instances à partir d’une instance de base. De même, une stratégie pourrait être clonée avec des paramètres différents (par ex. varier la durée des pauses). L’architecture doit supporter l’exécution multi-athlète facilement (par exemple en pouvant lancer la simulation sur une liste d’athlètes et de stratégies et stocker tous les résultats).
Comparaison de performances : on peut prévoir une fonctionnalité (par exemple dans utils.py ou directement dans simulator.py) pour comparer les résultats de plusieurs simulations. Par exemple, une fonction utilitaire compare_results(results: list[Result]) qui agrège les temps ou scores de plusieurs athlètes/stratégies sur un même WOD, afin de déterminer le meilleur temps, de calculer des écarts, ou de présenter un classement. Ceci facilitera l’analyse une fois qu’on aura simulé plusieurs clones. Le comparateur pourrait retourner un petit rapport (texte ou objet) ou même préparer des données pour une visualisation (graphique comparant les paces, etc.).
Chaque classe sera bien sûr entièrement typée (annotations de type Python) et documentée, ce qui améliore la clarté et facilite la maintenance du code
labex.io
. En séparant bien ces composants, on obtient une haute cohésion à l’intérieur de chaque module et un faible couplage entre modules. Chaque module a un rôle précis, ce qui donne un code ciblé et gérable
labex.io
. Par exemple, le simulateur utilise l’interface publique d’Athlete, de WOD et de Strategy sans dépendre des détails internes, ce qui fait que l’on peut modifier l’implémentation d’une classe (ou en ajouter de nouvelles) sans impacter les autres tant que l’interface reste stable.
Choix techniques recommandés
Dataclasses vs Pydantic : Pour modéliser les entités (Athlete, WOD, etc.), on recommande d’utiliser les dataclasses de Python plutôt que Pydantic pour démarrer. Les dataclasses permettent de définir simplement des classes de données immuables ou mutables avec un minimum de code, tout en tirant parti des annotations de type. Pydantic apporte des fonctionnalités supplémentaires (validation automatique, sérialisation facile, enforcement des types à l’exécution)
tinkerd.medium.com
, mais au prix d’une complexité et d’une dépendance additionnelle. Dans un MVP, cette validation poussée n’est pas forcément nécessaire puisque les données proviennent essentiellement du code lui-même. Étant donné le besoin de simplicité et de maintenabilité, on privilégie donc les dataclasses (ou même des classes classiques) avec type hints. On pourra toujours introduire Pydantic plus tard si le projet nécessite de charger/valider des données externes (fichiers de config, entrées utilisateur, etc.).
Typage statique : Il est conseillé d’utiliser systématiquement les annotations de type Python pour toutes les fonctions, méthodes et attributs. Le typage statique rend le code plus explicite et permet l’utilisation d’outils de vérification (mypy, pyright, etc.) pour attraper des erreurs dès le développement
labex.io
. Cela contribuera à la robustesse du projet, surtout dans un contexte multi-athlète où de nombreuses combinaisons seront testées. Les signatures de fonctions (par ex. def simulate(wod: WOD, athlete: Athlete, strategy: Strategy) -> Result:) serviront de documentation vivante de l’API de la librairie.
Configuration et données : Pour garder le MVP simple, on peut se passer de fichiers de configuration externes au début. Les profils d’athlète et les définitions de WOD peuvent être créés directement dans le code (ou éventuellement via des petits utilitaires Python si on veut scripter leur génération). Si le besoin s’en fait sentir, on pourra introduire plus tard un support de config (JSON/YAML) pour définir des athlètes ou WODs sans coder, mais ce n’est pas prioritaire. L’essentiel est que la conception modulaire actuelle n’empêche pas d’ajouter cette couche plus tard. Par exemple, on pourrait ajouter une fonction load_athlete_from_yaml(path) ou utiliser Pydantic pour définir des modèles et les charger d’un fichier – sans bouleverser l’architecture.
Qualité du code : On suivra les bonnes pratiques de développement Python pour un code propre et professionnel. Cela inclut le respect de PEP8 (nommage explicite, etc.), l’écriture de docstrings pour les classes et fonctions principales, et une structure de code cohérente. Il faut notamment éviter les importations circulaires entre modules (chaque module doit idéalement pouvoir être importé indépendamment)
labex.io
. La cohérence de style facilitera la collaboration et la maintenance. Il peut être utile de mettre en place des outils automatisés dès le début (un linter comme flake8/black, un outil de typage comme mypy dans la CI) afin d’assurer le respect de ces conventions sur le long terme.
Tests unitaires et interface utilisateur
La structure proposée inclut un dossier tests/ contenant des tests unitaires pour chaque composant clé. On peut utiliser pytest (ou unittest) pour écrire des tests simples et lisibles. Par exemple :
test_athlete.py vérifiera que la classe Athlete calcule correctement certains aspects de performance. Par ex., on peut tester une méthode simulant la fatigue : lui faire réaliser X répétitions d’un mouvement et vérifier que la fatigue calculée correspond à ce qui est attendu d’après les paramètres de l’athlète. On peut aussi tester que la conversion de performances connues (1RM, VMA, etc.) en paramètres internes se fait correctement.
test_workout.py pourra créer un WOD simple (quelques exercices de base) et vérifier que la structure est bien interprétée. Par ex., vérifier que le total de répétitions est correct, que le mode For Time vs AMRAP entraîne les effets attendus (un WOD For Time se termine quand toutes les reps sont faites, un AMRAP se bloque au time cap, etc.).
test_strategy.py définira une stratégie simple (ex: “tout faire unbroken sans pause”) et vérifiera que le plan de pacing généré correspond aux attentes. Par ex., si l’athlète ne peut faire que 20 pull-ups d’affilée et que le WOD en demande 30, la stratégie “unbroken” devra quand même prévoir une rupture (ou alors on considère qu’il essaie et échoue, selon la modélisation choisie). On teste que les fractionnements et repos recommandés par la stratégie sont cohérents.
test_simulator.py fera une simulation de bout en bout sur un scénario connu et vérifiera le résultat. Par ex., simuler un WOD très simple (10 répétitions d’un exercice facile) avec un athlète possédant une capacité connue (il peut faire les 10 reps sans pause) et une stratégie sans repos, puis vérifier que le temps total simulé correspond exactement au temps d’exécution de 10 répétitions sans pause. On peut aussi tester un AMRAP court avec un athlète et une stratégie données, où l’on sait d’avance combien de tours il devrait accomplir.
L’idée est que chaque module étant isolé, on peut tester son comportement indépendamment
labex.io
. Cette isolation facilite les tests unitaires et assure que les composants sont fiables individuellement avant de les combiner. On pourra intégrer ces tests dans une pipeline CI pour s’assurer que toute nouvelle modification n’introduit pas de régression. En ce qui concerne l’interface, l’approche MVP consistera d’abord à utiliser la librairie via un simple script ou en ligne de commande. Par la suite, pour une interface plus conviviale, Streamlit est un excellent choix (application web interactive). Pour préparer cela, on veille à ce que la librairie soit décorrélée de toute interface graphique : aucune fonction de la librairie ne réalisera d’input() ou de print() directement, ni n’interagira avec Streamlit. L’interface devra être une couche séparée qui importe la librairie. Par exemple, on pourra créer plus tard un fichier app_streamlit.py (ou un petit package app/) qui utilise Streamlit : on y importera les classes Athlete, WOD, Strategy, Simulator de la librairie, puis on construira une UI (sélection d’un WOD, sliders pour les paramètres d’athlète, choix d’une stratégie dans un menu déroulant, bouton Simuler qui appelle la fonction de simulation, et affichage du résultat). Grâce à la modularité de la librairie, cela sera simple à implémenter sans changement du code de base. De même, on pourrait envisager un CLI (interface en ligne de commande) qui parse des arguments (athlète, WOD, stratégie) et lance la simulation – ce serait un petit script séparé utilisant l’API de la librairie. L’important est que la librairie, elle, ne dépend pas de ces interfaces, ce qui garantit sa réutilisabilité maximale.
MVP pragmatique et évolutivité
Il est tentant de vouloir tout modéliser dès le départ (fatigue ultra-réaliste, toutes les variantes de WOD, etc.), mais il vaut mieux commencer avec un modèle simple puis l’améliorer par itérations successives. Pour un MVP, on peut faire des choix simplificateurs raisonnables : par exemple modéliser la fatigue de façon linéaire ou avec une formule basique, ne gérer initialement que les WOD de type For Time et AMRAP, et limiter les paramètres d’athlète à l’essentiel (force, endurance, etc.). L’objectif est d’obtenir une simulation opérationnelle “suffisamment bonne pour l’objectif visé, sans être plus complexe que nécessaire”. Grâce à l’architecture modulaire proposée, le projet sera ensuite facile à faire évoluer sans tout refactorer
labex.io
. De nouvelles fonctionnalités pourront s’ajouter par couches successives. Par exemple :
Ajouter un nouveau type de WOD (EMOM, rounds à temps fixe, etc.) pourra se faire en étendant la classe WOD (ou en créant une sous-classe spécifique) et en adaptant légèrement le simulateur pour prendre en compte la logique propre à ce type, sans affecter les autres modules.
Introduire une nouvelle stratégie de pacing n’impactera pas le reste du code : il suffira de créer une classe supplémentaire dans strategy.py implémentant l’interface de Strategy (par exemple une méthode plan_pacing(self, wod, athlete) qui retourne un plan d’exécution). Le simulateur pourra utiliser cette nouvelle stratégie de manière interchangeable avec les précédentes, du moment qu’elle respecte l’interface attendue.
Affiner le modèle d’athlète (ajout d’un paramètre de récupération, d’une métrique de VO2max, etc.) impliquera de modifier la classe Athlete et éventuellement la logique du Simulator, mais grâce aux tests unitaires en place et à l’encapsulation, on pourra vérifier que le reste du système fonctionne toujours correctement.
En résumé, la librairie sera organisée de manière professionnelle et claire, avec des composants modulaires petits et ciblés
labex.io
. On mise sur la simplicité du MVP tout en posant une base solide pour la scalabilité. Cette approche facilitera les tests (chaque partie peut être validée isolément) ainsi que la future intégration d’une interface utilisateur, le tout sans avoir à remanier la logique métier existante. Sources : Les principes de modularité et de séparation des responsabilités sont inspirés des bonnes pratiques de conception logicielle
labex.io
labex.io
. L’utilisation des dataclasses et du typage statique est privilégiée pour la simplicité, Pydantic n’étant ajouté que si nécessaire
tinkerd.medium.com
. On s’appuie sur une démarche itérative de modélisation – « all models are wrong, but some are useful » – en commençant simple puis en complexifiant progressivement. Ces choix visent à obtenir une librairie propre, testable et évolutive, prête pour d’éventuelles extensions (comme une interface Streamlit).



Sources



Aucun fichier choisiAucun fichier choisi
ChatGPT peut commettre des erreurs. Il est recommandé de vérifier les informations importantes. Voir les préférences en matière de cookies.
